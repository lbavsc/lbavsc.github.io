<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Activity的启动模式]]></title>
    <url>%2F2019%2F11%2F11%2FActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity 的启动模式1. Activity为什么需要启动模式？ 默认情况，多次启动同一个 Activity 时，系统会创建多个实例并一一放入任务栈中，单击 back 键时，会一一回退（每按一次back就会有一个 Activity 出栈，直至栈空，当栈空时，系统回收次任务栈） 为了根据实际需求，例如不需要重复创建 Activity 时，就要使用其他启动模式。 2. 有哪几种启动模式standard（标准模式） singleTop（栈顶复用模式） singleTask（栈内复用模式） singleInstance（单实例模式） 3. standard（标准模式）：系统默认模式，每启动一个 Activity 都会重建一个实例（即使是同一个 Activity ）, 实例符合activity的生命周期，onCreate、onStart、onResume 都会被调用，属于典型的多实例实现。一个任务栈可以存在多个实例，每个实例也可以属于不同的任务栈。 该模式下，谁启动的 Activity ，这个 Activity 就运行在启动它的那个 Activity 的任务栈中。 但由于非 Activity 类型的 Context （例如 ApplicationContext ）并没有任务栈，所以用 ApplicationContext 去启动该模式的 Activity 时就会出现错误情况。解决方法是为待启动的 Activity 指定 FLAG_ACTIVITY_NEW_TASK 标记位，这样启动时就会为该 Activity 创建一个新的任务栈， 这个时候待启动的 Activity 实际上是以 singTask（栈内复用模式）启动的。 1234567st=&gt;start: 开始op=&gt;operation: 启动Activityoo=&gt;operation: 创建Activity实例e=&gt;end: 结束st-&gt;opop-&gt;oooo-&gt;e 4. singTop（栈顶复用模式）：该模式下，如果新的 Activity 已经位于任务栈的栈顶，那么此 Activity 不会被重新创建，同时它的onNewInter 方法会被回调，通过此方法的参数可以取出当前请求的信息。 但在此情况下，该 Activity 的 onCreate、onStart 不会被系统调用，因为它没有发生变化。 如果新的 Activity 的实例存在但不是位于栈顶，那么仍会创建新的 Activity 实例。 123456789101112st=&gt;start: 任务栈op=&gt;operation: Activity实例as=&gt;operation: 创建新 Activity 实例ad=&gt;operation: 将 Activity 移至栈顶cond=&gt;condition: 是否存在？cond2=&gt;condition: 是否位于栈顶？e=&gt;end: 结束st-&gt;op-&gt;condcond(yes)-&gt;cond2cond(no)-&gt;ascond2(yes)-&gt;econd2(no)-&gt;as 5. singTask（栈内复用模式）：这是一种单实例模式，即只要 Activity 在栈内存在，那么即使多次启动 Activity 都不会重新创建实例。该模式也会回调其 onNewInter 。 例如： 当一个具有 singleTask 模式的 Activity请求启动后，系统首先会寻找该 Activity 想要的任务栈，如果任务栈不存在，则创建一个任务栈， 然后创建该 Activity 放入任务栈中。如果任务栈存在，则需要看该Activity的实例是否存在，存在则系统会把该 Activity 调到栈顶并调用它的 onNewInter 方法，如果Activity实例不存在，就创建 Activity 的实例并把 Activity 压入栈中。 1234567891011121314151617181920 st=&gt;start: Activity op=&gt;operation: A请求启动cond=&gt;condition: 任务栈存在?st-&gt;op-&gt;condop2=&gt;operation: 创建新的任务栈op3=&gt;operation: 创建A实例op4=&gt;operation: 将A放入任务栈op2-&gt;op3-&gt;op4cond2=&gt;condition: A实例存在?cond(no)-&gt;op2cond(yes)-&gt;cond2op5=&gt;operation: 将A调至栈顶op6=&gt;operation: 调用A的onNewInter方法op5-&gt;op6op7=&gt;operation: 压入栈中cond2(yes)-&gt;op5cond2(no)-&gt;op3 e=&gt;end: 结束 op4-&gt;e op6-&gt;e 如 S1 任务栈中存在 ABC 实例，这是 Activity D 以 singleTask 模式请求启动，所需任务栈为 S2，由于 S2 与 D 都不存在，则先创建 S2 ，然后创建 D 的实例并将其入栈到 S2 。 如果 D 所需栈为 S1 ，其他如上，则系统会直接创建 D 的实例并将其入栈到 S1 。 如果 D 所需栈为S1 ，且栈内此时情况为 ADBC ，根据复用原则，此时 D 不会重新创建，系统会把 D 切换到栈顶并调用其 onNewInter 方法，同时由于 singleTask 默认具有 cleaeTop 效果，会导致栈内所有在 D 上面的 Activity 全部出栈， 于是最终 S1 中的情况为 AD 。 6. singleInstance（单实例模式）：这是一种加强的 singTask 实例，它除了具有 singTask 模式的所有特性之外，还加强了一点，那就是具有此种模式的 Activity 只能单独地位于一个任务栈中，比如 Activity A 是singleInstance模式，当 A 启动后，系统会为它创建一个新的任务栈，然后 A 单独位于这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的 A ，除非 A 已经被销毁了。 7. 某些应用情况假设现在有俩个任务栈，前台任务栈的情况为 AB ，后台任务栈的情况为 CD ，假设 CD 的启动模式均为 singTask 。 现在请求启动 D ，那么整个后台任务栈都会被切换到前台，这个时候整个后退列表就变成了 ABCD 。当用户按下 back 键时，列表中的 Activity 会一一出栈；但如果是请求 C 而不是请求 D ，任务栈会变成 ABC ，D 直接被出栈了 8. 如何指定Activity的启动模式 通过 AndroidMenifest 为 Activity 指定启动模式 1234&lt;activity android:name=".ui.activity.MainActivity" android:screenOrientation="portrait" android:launchMode="singleTask"/&gt; 通过 Intent 中设置标志位来为 Activity 指定启动模式1234Intent intent = new Intent();intent.setClass(MainActivity.this, LoginActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 俩者虽都能为 Activity 指定启动模式，当俩种方式同时存在时，但第二种优先级是高于第一种的；其次，上述俩种方式在限定范围上有所不同，比如，第一种方式无法直接为 Activity 设定 FLAG_ACTIVITY_VLEAR_TOP 标识，而第二种无法为 Activity 指定 singInstance 模式。 资料来源：《Android开发艺术探索》]]></content>
      <tags>
        <tag>Android, Activity, Android开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无限期停更]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%97%A0%E9%99%90%E6%9C%9F%E5%81%9C%E6%9B%B4%2F</url>
    <content type="text"><![CDATA[计划因为现实原因，无限期退后，可能明天就有时间写了，也可能明年。]]></content>
  </entry>
</search>
